# [RFC] レビューループ自動化（/arfc, /aimp）

| 項目 | 内容 |
| :--- | :--- |
| **作成者 (Author)** | AI (RFC Author) |
| **ステータス** | Accepted (承認済) |
| **作成日** | 2026-02-06 |
| **タグ** | workflow, commands, review |
| **関連リンク** | [vdevフロー改善調査レポート](../../reports/20260204-vdev-flow-analysis.md) |

## 1. 要約 (Summary)

vdev の RFC駆動開発フローにおいて、AI同士のレビュー往復（`/rrfc` ↔ `/urfc`、`/rimp` ↔ `/uimp`）を自動化する新コマンド `/arfc` と `/aimp` を導入する。併せて、以下の新思想を既存コマンドに直接組み込み、新旧コマンド間の一貫性を確保する。

- Severity 定義を現行の2段階（P0/P1）から3段階（P0/P1/P2）に再設計し、全コマンドに統一適用する
- レビュー結果を統合するシンセサイザー Task を `/rrfc` `/rimp` に組み込む
- ラウンド自動判定と差分レビュー戦略を `/rrfc` `/rimp` に組み込む
- `/imp` からタスク計画承認を削除する

`/arfc` は `/rfc` `/rrfc` `/urfc` を、`/aimp` は `/imp` `/rimp` `/uimp` を Task 経由で内部呼び出しする構造とし、定義の重複を排除する。全処理フェーズを Task サブエージェントとして実行する「薄いオーケストレータ」設計を採用し、コンテキスト圧迫と人格混線の問題を構造的に解決する。

## 2. 背景・動機 (Motivation)

### 現状の課題

現行フローでは、RFC作成後のレビューサイクルおよび実装後のレビューサイクルにおいて、人間が以下のコマンドを都度手動で実行している。

```
RFCフェーズ:  /rfc → /rrfc → /urfc → /rrfc → ... → Approve
実装フェーズ: /imp → /rimp → /uimp → /rimp → ... → Approve
```

この手動中継には以下の問題がある。

1. **無意味な手動操作**: `/rrfc` → `/urfc` → `/rrfc` の中継は AI 同士のやりとりであり、人間は「次のコマンドを打つだけ」の存在になっている。個人開発ではこのオーバーヘッドが体験を著しく損ねる。
2. **コンテキスト断絶**: コマンド間で `/clear` を手動実行しているため、前のコマンドの文脈が失われる。本来不要な情報の再読み込みが発生している。
3. **P1 指摘の非収束**: レビューの P1（Nit）が毎ラウンド再生産され、実質的に収束しない。P1 の定義が広すぎるため、「具体的な改善提案」と「代替案の FYI」が混在している。手動フローでは往復コストが高いため、P1 残がある状態で通しているケースが多い。

### 放置した場合のリスク

- 個人開発における vdev フローの形骸化（手間を避けてレビューをスキップする傾向の加速）
- レビュー品質の低下（P1 対応が不十分なまま Approve される常態化）

## 3. 目的とスコープ (Goals & Non-Goals)

### 目的 (Goals)

- AI 同士のレビュー往復を自動化し、人間の手動操作を「元ネタ入力 → RFC PR マージ → 実装 PR マージ」の3回に削減する
- Severity 定義を P0/P1/P2 の3段階に再設計し、既存コマンドを含む全コマンドに統一適用することで、P1 の収束性を構造的に確保する
- シンセサイザー Task の導入により、レビュー結果の重複排除・矛盾解決・優先順位付けを自動化する
- 全 Phase の Task 化により、コンテキスト圧迫と人格混線を解消する
- `/arfc` は `/rfc` `/rrfc` `/urfc` を、`/aimp` は `/imp` `/rimp` `/uimp` を内部で呼び出す構造とし、定義の重複を排除する
- シンセサイザー・ラウンド判定・差分レビュー戦略を既存コマンド（`/rrfc`, `/rimp`）に直接組み込み、手動実行時にも同じ恩恵を提供する
- `/imp` からタスク計画承認を削除し、RFC 承認を設計合意の完了とみなす

### やらないこと (Non-Goals)

- エンタープライズ向けプロファイル制の導入（将来課題として別 RFC で扱う）
- `/arfc` → `/aimp` の完全一気通貫自動化（RFC PR マージという人間のチェックポイントは維持する）

## 4. 前提条件・依存関係 (Prerequisites & Dependencies)

- Claude Code の Task ツール（サブエージェント）が利用可能であること
- 既存の vdev コマンド体系（`adapters/claude/commands/`）が動作していること
- `rfc-init`, `rfc-publish` スクリプトが利用可能であること

## 5. 詳細設計 (Detailed Design)

### 5.1 全体アーキテクチャ

#### 設計原則：薄いオーケストレータ

メインエージェントはループ制御と判定分岐のみを担い、ファイル読み込み・分析・執筆・レビューはすべて Task サブエージェントで実行する。

```
メインエージェント（オーケストレータ）:
  保持する情報: slug, ファイルパス, ラウンド番号, 判定結果
  行わない処理: ファイル読み込み, RFC/コード分析, 執筆, レビュー

各 Task サブエージェント:
  独立したコンテキストで起動・完了
  必要なファイルは自身で読み込む
```

この設計により以下が達成される。

- **コンテキスト圧迫の解消**: 各 Task は独立コンテキストで動作し、メインエージェントには結果のみが返る。手動フローでの `/clear` と同等以上の分離効果。
- **人格混線の解消**: RFC Author と各 Reviewer が完全に別コンテキストで動作する。Author のコンテキストに Reviewer の指摘文が蓄積しない。

#### `/arfc` のフロー

`/arfc` は既存コマンドを Task 経由で内部呼び出しするだけの薄いオーケストレータである。レビュー・シンセサイズ・ラウンド判定はすべて `/rrfc` 内で完結する。

```
Phase 1: RFC作成
  → Task が /rfc コマンドを読み込み実行
  ← slug, RFCパス を取得

Phase 2: レビューループ（最大3イテレーション）
  Step A: Task が /rrfc コマンドを読み込み実行
          （/rrfc 内で並列レビュー → シンセサイザー → コミット&プッシュが完結）
  Step B: 判定（メイン: /rrfc の結果を確認）
           Approve → 完了（/rrfc 内で Accepted 更新・gh pr ready 済み）
           Request Changes かつ iteration < 3 → Step C へ
           Request Changes かつ iteration >= 3 → ユーザに報告して終了
  Step C: Task が /urfc コマンドを読み込み実行（RFC修正・コミット&プッシュ）
  → Step A に戻る
```

#### `/aimp` のフロー

`/arfc` と同構造。既存コマンドの呼び出し先が異なるのみ。

```
Phase 1: 実装
  → Task が /imp コマンドを読み込み実行

Phase 2: レビューループ（最大3イテレーション）
  Step A: Task が /rimp コマンドを読み込み実行
  Step B: 判定（メイン: /rimp の結果を確認）
           Approve → 完了（/rimp 内で gh pr ready 済み）
           Request Changes かつ iteration < 3 → Step C へ
           Request Changes かつ iteration >= 3 → ユーザに報告して終了
  Step C: Task が /uimp コマンドを読み込み実行（コード修正・テスト・コミット&プッシュ）
  → Step A に戻る
```

### 5.2 Severity 3段階定義

現行の P0/P1 を P0/P1/P2 の3段階に再設計し、全コマンド（既存の `/rrfc`, `/rimp` を含む）に統一適用する。

| Severity | 名称 | 定義 | Author の対応 |
| :--- | :--- | :--- | :--- |
| **P0 (Blocker)** | 修正必須 | 論理的欠陥、仕様漏れ、重大なリスク、回答必須の質問 | 必ず対応 |
| **P1 (Improvement)** | 具体的改善 | 修正内容と期待効果が明確な具体的改善提案 | 原則対応 |
| **P2 (Note)** | 記録のみ | 代替案の提示、将来的な懸念、参考情報 | 対応不要 |

#### P1 判定基準

レビュアーは以下をすべて満たす場合のみ P1 とする。

- 修正内容を具体的に示せること（「〜を検討」ではなく「〜に変更」）
- 修正による品質向上が明確であること
- 現在のスコープ内で対応可能であること

上記を満たさない指摘は P2 とする。

#### 出力上限

| Severity | 上限/レビュアー | 3レビュアー合計 | シンセサイザー統合後 |
| :--- | :--- | :--- | :--- |
| P0 | 5件 | 15件 | 重複排除後の全件 |
| P1 | 3件 | 9件 | 上位5件 |
| P2 | 2件 | 6件 | 全件（記録のみ） |

### 5.3 シンセサイザー Task

3人のレビュアーの出力を統合し、Author 向けの単一アクションプランを生成する第4の Task。`/rrfc` および `/rimp` の標準ステップとして組み込む。手動実行（`/rrfc` 単体）でも自動ループ（`/arfc` 経由）でも同一のシンセサイズ処理が実行される。

#### 入力

- `review-approach.md`（または `review-imp-approach.md`）
- `review-security-risk.md`（または `review-imp-security-risk.md`）
- `review-quality.md`（または `review-imp-quality.md`）

#### 処理

1. 全レビューから P0 / P1 / P2 を抽出する
2. 重複する指摘を統合する（同一箇所・同一趣旨 → 1件に集約）
3. 矛盾する指摘を処理する（下記の矛盾解決ルールに従う）
4. P0 を重要度順に並べる
5. P1 を対応効果が高い順に並べ、上位5件のみアクション対象とする
6. P2 を記録セクションに列挙する（対応不要と明記）
7. 解決できない矛盾がある場合、「要判断」セクションに併記する

#### 矛盾解決の処理

レビュアー間で矛盾する指摘が発生した場合、シンセサイザーは以下の手順で処理する。

**Step 1: 併存可能性の判断**

両方の指摘を同時に反映できる場合、両方をアクション対象とする（矛盾解決不要）。

- 例: 「エラーハンドリングを追加」と「ログ出力を追加」は両立可能
- 例: 「命名を改善」と「テストを追加」は両立可能

多くの「矛盾」は実際には併存可能であり、両方対応すれば解決する。

**Step 2: 排他的矛盾の自動解決（以下の条件を満たす場合のみ）**

- **Severity 差**: P0 vs P1/P2 → P0 を採用
- **根幹否定**: Approach Reviewer が「そもそもやるべきでない」「前提が誤っている」と判断 → Approach を採用

自動解決した場合、アクションプランの該当指摘に以下を付記する。

```markdown
- **矛盾解決**: {棄却したレビュアー名} の指摘「{要旨}」と矛盾。{採用理由} により本指摘を採用。
```

**Step 3: 上記以外の排他的矛盾 → 人間判断**

Step 1, 2 で解決できない排他的矛盾は、アクションプランに「要判断」セクションとして併記し、人間に委ねる。

```markdown
## 要判断（矛盾する指摘）

**[矛盾-1] {トピック}**
- **指摘A** ({レビュアー名}): {内容}
- **指摘B** ({レビュアー名}): {内容}
- **シンセサイザー所見**: {どちらが妥当と思われるかの意見}
```

自動ループは継続するが、Author は該当箇所の修正を保留する。人間が次ラウンドまでに判断し、`/urfc` で方針を指示する。

この設計により、明確なケースは自動解決し、曖昧なケースは人間に委ねる。

#### 出力フォーマット（`action-plan-r{N}.md`）

```markdown
# レビュー統合アクションプラン（ラウンド {N}）

## 判定
- **Status**: [Approve / Request Changes]
- **P0 件数**: {N} 件
- **P1 件数**: {N} 件（アクション対象: {M} 件）
- **P2 件数**: {N} 件（記録のみ）

## 必須対応 (P0)
**[P0-1] {統合後の指摘タイトル}**
- **出典**: {Approach / Security / Quality}
- **内容**: {具体的な問題点}
- **修正方針**: {具体的な修正内容}

## 推奨対応 (P1) — 上位5件
**[P1-1] {統合後の指摘タイトル}**
- **出典**: {レビュアー名}
- **内容**: {提案内容}
- **修正方針**: {具体的な修正内容}

## 記録のみ (P2)
- {内容}（出典: {レビュアー名}）

## 要判断（矛盾する指摘）
**[矛盾-1] {トピック}**
- **指摘A** ({レビュアー名}): {内容}
- **指摘B** ({レビュアー名}): {内容}
- **シンセサイザー所見**: {どちらが妥当と思われるかの意見}
```

「要判断」セクションは、矛盾が発生した場合のみ出力する。矛盾がなければ省略する。

### 5.4 ラウンド別レビュー戦略

ラウンド判定・差分レビュー戦略は `/rrfc` `/rimp` に直接組み込む。手動実行でも自動ループでも同一の戦略が適用される。

#### 設計思想：段階的収束モデル

ラウンドを重ねるごとにレビューの焦点を絞り、収束を目指す。具体的には、報告対象の Severity レベルと修正件数の上限をラウンドごとに段階的に引き下げる。

- **ラウンド1**: 全 Severity を報告し、P0 全件 + P1 上位5件を修正対象とする
- **ラウンド2**: P0 + P1 を報告し、P0 全件 + P1 上位3件を修正対象とする（P2 は報告しない）
- **ラウンド3**: P0 のみを報告し、P0 全件を修正対象とする（P1/P2 は報告しない）

この設計により、P1（原則対応）の指摘がラウンド1〜2で確実に対応機会を得つつ、ラウンド3ではP0に絞ることで無限ループを防止する。

#### ラウンド自動判定

`/rrfc` `/rimp` は実行時に `action-plan-r{N}.md`（または `action-plan-imp-r{N}.md`）の存在を確認し、ラウンド番号を自動判定する。

- `action-plan-r*.md` が0件 → ラウンド1（初回）
- `action-plan-r*.md` が N 件 → ラウンド N+1

#### ラウンド別の振る舞い

| ラウンド | レビュー範囲 | 出力 Severity | 修正範囲 | Approve 条件 |
| :--- | :--- | :--- | :--- | :--- |
| 1 | 全文フルレビュー | P0 + P1 + P2 | P0 全件 + P1 上位5件 | P0 = 0 かつ P1 = 0 |
| 2 | 変更差分のみ | P0 + P1 | P0 全件 + P1 上位3件 | P0 = 0 かつ P1 = 0 |
| 3 | 変更差分のみ | P0 のみ | P0 全件 | P0 = 0 |

#### 2ラウンド目のレビュー Task プロンプト追加指示

`/rrfc` `/rimp` がラウンド2と判定した場合、レビュー Task のプロンプトに以下を追加する。

```markdown
## 追加コンテキスト（ラウンド 2）
- これはレビュー第2ラウンドである。
- 前回のアクションプラン: {action-plan-r1.md の絶対パス}
- 前回レビュー以降の変更差分のみをレビュー対象とせよ。
- P0 および P1 を報告せよ。P2 は報告不要。

## 変更差分の取得方法
以下の git diff コマンドを Bash ツールで実行し、差分を取得せよ:
git diff HEAD~1 -- {対象ファイルパス}

RFC レビューの場合は `docs/rfcs/<slug>/rfc.md` の差分を取得する。
実装レビューの場合はレビュー対象ファイル群の差分を取得する。
```

#### 3ラウンド目のレビュー Task プロンプト追加指示

`/rrfc` `/rimp` がラウンド3と判定した場合、レビュー Task のプロンプトに以下を追加する。

```markdown
## 追加コンテキスト（ラウンド 3）
- これはレビュー第3ラウンドである。
- 前回のアクションプラン: {action-plan-r2.md の絶対パス}
- 前回レビュー以降の変更差分のみをレビュー対象とせよ。
- P0 のみ報告せよ。P1 / P2 は報告不要。

## 変更差分の取得方法
以下の git diff コマンドを Bash ツールで実行し、差分を取得せよ:
git diff HEAD~1 -- {対象ファイルパス}

RFC レビューの場合は `docs/rfcs/<slug>/rfc.md` の差分を取得する。
実装レビューの場合はレビュー対象ファイル群の差分を取得する。
```

#### 差分レビューの実現方法

2ラウンド目以降のレビュー Task は、以下の手順で差分レビューを実行する。

1. **差分取得**: `git diff HEAD~1 -- <対象ファイル>` で前回コミットからの変更差分を取得する
2. **アクションプラン参照**: 前回の `action-plan-r{N-1}.md` を読み込み、どの指摘に対する修正かを把握する
3. **差分レビュー**: 差分箇所が指摘に対して適切に対応しているか、および新たな問題が混入していないかを確認する

この方法により、Task サブエージェントは独立したコンテキストでも差分情報にアクセスできる。

#### シンセサイザーのラウンド別処理

- **ラウンド1**: P0 / P1 / P2 すべてを処理対象とする。P1 は上位5件をアクション対象とする。
- **ラウンド2**: P0 / P1 を処理対象とする。P1 は上位3件をアクション対象とする。P2 セクションは「該当なし（ラウンド2では P0 + P1 限定）」と記載する。
- **ラウンド3**: P0 のみを処理対象とする。P1/P2 セクションは「該当なし（ラウンド3では P0 限定）」と記載する。

### 5.5 ファイル管理とバージョニング

#### レビュー結果ファイル（上書き）

```
docs/rfcs/<slug>/
  review-approach.md           ← 毎ラウンド上書き
  review-security-risk.md      ← 毎ラウンド上書き
  review-quality.md            ← 毎ラウンド上書き
```

3人格のレビュー結果はシンセサイザーへの入力に過ぎないため、最新ラウンドの結果のみをファイルとして保持する。過去ラウンドの原文は git history で追跡可能。

#### アクションプラン（バージョン蓄積）

```
docs/rfcs/<slug>/
  action-plan-r1.md            ← ラウンド1の統合結果（保持）
  action-plan-r2.md            ← ラウンド2の統合結果（保持）
  action-plan-r3.md            ← ラウンド3の統合結果（保持）
```

アクションプランは自動化プロセスの監査証跡として機能する。ラウンド間の変化（P0 件数の推移、指摘内容の変遷）を人間が後から追跡できる。

実装レビューでは `action-plan-imp-r{N}.md` とする。

#### コミット戦略

ラウンドごとにまとめてコミットし、コミットメッセージにラウンド番号を含める。

```
# ラウンド1 レビュー結果
docs: add review results (round 1) for <slug>

# ラウンド1 RFC修正
docs: revise RFC for <slug> (round 1 fixes)

# ラウンド2 レビュー結果
docs: add review results (round 2) for <slug>
```

### 5.6 新規ファイル一覧

| ファイル | 配置先 | 説明 |
| :--- | :--- | :--- |
| `arfc.md` | `adapters/claude/commands/` | `/arfc` コマンド定義 |
| `aimp.md` | `adapters/claude/commands/` | `/aimp` コマンド定義 |
| `synthesizer.md` | `prompts/roles/` | シンセサイザー人格定義 |
| `review-default.md` | `templates/review/` | 既存テンプレートを P0/P1/P2 に更新 |
| `action-plan-default.md` | `templates/review/` | アクションプランテンプレート |

### 5.7 既存ファイル変更一覧

| ファイル | 変更内容 |
| :--- | :--- |
| `prompts/criterias/rfc-review.md` | P1 判定基準の追記、P2 定義の追加 |
| `prompts/criterias/impl-review.md` | 同上 |
| `adapters/claude/commands/rrfc.md` | Severity を P0/P1/P2 に更新、シンセサイザー実行ステップの追加、ラウンド自動判定の追加、2ラウンド目以降の差分レビュー・P0限定戦略の追加 |
| `adapters/claude/commands/rimp.md` | 同上 |
| `adapters/claude/commands/imp.md` | タスク計画承認（Step 4）の削除 |
| `adapters/claude/commands/urfc.md` | P2 対応不要の方針を明記 |
| `adapters/claude/commands/uimp.md` | 同上 |
| `templates/review/review-default.md` | P2 セクションの追加 |

新思想（Severity 3段階、シンセサイザー、ラウンド判定、差分レビュー戦略）は既存コマンドに直接組み込む。`/arfc` `/aimp` はこれらを呼び出すだけの薄いオーケストレータとし、定義の重複を排除する。

## 6. 代替案の検討 (Alternatives Considered)

### 案A: 既存コマンドにフラグ追加（`/rrfc --auto`）

- **概要**: 既存の `/rrfc`, `/rimp` に `--auto` フラグを追加し、Request Changes 時に自動で修正→再レビューを実行する。
- **長所**: 新規コマンド不要。既存コマンドの拡張で済む。
- **短所**: 既存コマンドの複雑化。フラグの有無で挙動が大きく変わり、保守性が低下する。既存コマンドの安定性にリスクが及ぶ。

### 案B: シェルスクリプトによるオーケストレーション

- **概要**: `bin/auto-rfc` のようなシェルスクリプトで `/rfc` → `/rrfc` → `/urfc` を順次呼び出す。
- **長所**: コマンド定義に手を入れずに実現可能。
- **短所**: Claude Code のスラッシュコマンドはシェルから呼び出せない（AI プロンプトとして実行される仕組み）。技術的に実現不可能。

### 案C: 新規複合コマンド + 既存コマンドへの新思想組み込み + Severity 統一再設計（採用案）

- **概要**: `/arfc`, `/aimp` を新設。新思想（シンセサイザー、ラウンド判定、差分レビュー戦略、Severity 3段階）をすべて既存コマンド（`/rrfc`, `/rimp`, `/imp` 等）に直接組み込む。`/arfc` は `/rfc` `/rrfc` `/urfc` を、`/aimp` は `/imp` `/rimp` `/uimp` を Task 経由で内部呼び出しする構造とし、定義の重複を排除する。
- **長所**: Severity 定義が一元化され保守性向上。コンテキスト分離が構造的に保証される。P1 収束問題を Severity 再設計とシンセサイザーで根本解決。手動実行時にもシンセサイザーや差分レビュー戦略の恩恵を受けられる。`/arfc` `/aimp` はオーバーライドなしで既存コマンドを呼ぶだけの構造となり、定義の一元管理が実現する。
- **短所**: 既存コマンドの変更範囲が大きい（リグレッションリスク）。シンセサイザーという新しい概念の導入。

### 選定理由

案C を採用する。案A は既存コマンドの複雑化リスクがあり、案B は技術的に不可能である。案C は新思想を既存コマンドに組み込むことで、手動実行と自動ループの両方で一貫した体験を提供できる。既存コマンドの変更範囲は大きいが、新旧で異なる体系が併存するリスクを排除でき、長期的な保守性が向上する。

## 7. 横断的関心事 (Cross-Cutting Concerns)

### 7.1 セキュリティとプライバシー

本変更はローカル開発ワークフローの自動化であり、セキュリティ上の新たなリスクはない。

### 7.2 スケーラビリティとパフォーマンス

- **Token 消費**: 全 Phase Task 化により、メインエージェントの Token 消費は大幅に削減される。一方、Task 起動数が増えるため、全体の Token 消費はやや増加する可能性がある（シンセサイザー Task の追加分）。
- **実行時間**: 並列レビュー（3 Task 同時）は維持。シンセサイザー Task は直列追加（+1 Task）。全体の実行時間はシンセサイザー分だけ増加するが、手動でのコマンド入力待ち時間の削減により、エンドツーエンドの所要時間は短縮される。

### 7.3 可観測性 (Observability)

- アクションプランのバージョンファイル（`action-plan-r{N}.md`）がプロセスの監査証跡として機能する
- コミットメッセージにラウンド番号を含めることで、git history からも追跡可能

### 7.4 マイグレーションと後方互換性

- 既存コマンドへの変更:
  - `/rrfc` `/rimp`: Severity を P0/P1/P2 に変更、シンセサイザー・ラウンド判定・差分レビュー戦略を追加
  - `/imp`: タスク計画承認を削除
  - `/urfc` `/uimp`: P2 対応不要の方針を明記
- 既存コマンドの利用者への影響:
  - レビュー出力に P2 カテゴリが追加される（新規追加、情報量増加）
  - P1 の定義が厳格化される（「具体的改善提案」に限定）
  - 従来 P1 だった一部の指摘が P2 に分類される（対応負荷軽減）
  - `/rrfc` `/rimp` にシンセサイザーが追加される（レビュー結果の自動統合）
  - `/rrfc` `/rimp` の2回目以降の実行が差分レビュー・P0限定になる（効率向上）
  - `/imp` のタスク計画承認が不要になる（ステップ削減）
- 既存コマンドを使い続けることも可能（`/arfc` と `/rfc` + `/rrfc` + `/urfc` は共存する）

## 8. テスト戦略 (Test Strategy)

vdev はプロンプト定義とシェルスクリプトで構成されるため、自動テストの対象は限定的である。以下の手動検証を行う。

- `/arfc` を実プロジェクトで実行し、レビューループが正常に動作することを確認する
  - Phase 1（RFC作成）が Task として正常に完了すること
  - Phase 2（レビューループ）で3並列レビュー + シンセサイザーが動作すること
  - Request Changes 時にループが継続し、Approve 時に終了すること
  - 最大3イテレーションでガードされること
  - アクションプランが `action-plan-r{N}.md` として蓄積されること
- `/aimp` を実プロジェクトで実行し、同等の検証を行う
  - Phase 1 で実装タスク策定から PR 作成まで一気通貫で完了すること
  - テスト実行が修正ループ内で正常に動作すること
- Severity 3段階（P0/P1/P2）が正しく分類されることを確認する
- シンセサイザーの重複排除・矛盾解決が妥当であることを確認する

## 9. 実装・リリース計画 (Implementation Plan)

### フェーズ1: 基盤整備

1. Severity 3段階定義の追加（`prompts/criterias/rfc-review.md`, `impl-review.md`）
2. レビューテンプレートの更新（`templates/review/review-default.md` に P2 追加）
3. シンセサイザー人格定義の作成（`prompts/roles/synthesizer.md`）
4. アクションプランテンプレートの作成（`templates/review/action-plan-default.md`）

### フェーズ2: 既存コマンドへの新思想組み込み

1. `/rrfc` の更新: シンセサイザー実行ステップの追加、ラウンド自動判定の追加、2ラウンド目以降の差分レビュー・P0限定戦略の追加
2. `/rimp` の更新: `/rrfc` と同様の変更
3. `/imp` の更新: タスク計画承認の削除
4. `/urfc` `/uimp` の更新: P2 対応不要の方針を明記

### フェーズ3: /arfc, /aimp コマンド実装

1. `adapters/claude/commands/arfc.md` の作成（`/rfc` `/rrfc` `/urfc` を内部呼び出し）
2. `adapters/claude/commands/aimp.md` の作成（`/imp` `/rimp` `/uimp` を内部呼び出し）
3. 実プロジェクトでの動作検証

### システム概要ドキュメントへの影響

vdev リポジトリには `docs/architecture.md` 等のシステム概要ドキュメントは存在しないため、影響なし。
