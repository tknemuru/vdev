# [RFC] レビューループ自動化（/arfc, /aimp）

| 項目 | 内容 |
| :--- | :--- |
| **作成者 (Author)** | AI (RFC Author) |
| **ステータス** | Draft (起草中) |
| **作成日** | 2026-02-06 |
| **タグ** | workflow, commands, review |
| **関連リンク** | [vdevフロー改善調査レポート](../../reports/20260204-vdev-flow-analysis.md) |

## 1. 要約 (Summary)

vdev の RFC駆動開発フローにおいて、AI同士のレビュー往復（`/rrfc` ↔ `/urfc`、`/rimp` ↔ `/uimp`）を自動化する新コマンド `/arfc` と `/aimp` を導入する。併せて、レビューの Severity 定義を現行の2段階（P0/P1）から3段階（P0/P1/P2）に再設計し、既存のレビューコマンド（`/rrfc`, `/rimp`）にも統一適用する。レビュー結果を統合するシンセサイザー Task を新設する。全処理フェーズを Task サブエージェントとして実行する「薄いオーケストレータ」設計を採用し、コンテキスト圧迫と人格混線の問題を構造的に解決する。`/arfc` は既存の `/rfc` を内部で呼び出す構造とし、定義の重複を回避する。

## 2. 背景・動機 (Motivation)

### 現状の課題

現行フローでは、RFC作成後のレビューサイクルおよび実装後のレビューサイクルにおいて、人間が以下のコマンドを都度手動で実行している。

```
RFCフェーズ:  /rfc → /rrfc → /urfc → /rrfc → ... → Approve
実装フェーズ: /imp → /rimp → /uimp → /rimp → ... → Approve
```

この手動中継には以下の問題がある。

1. **無意味な手動操作**: `/rrfc` → `/urfc` → `/rrfc` の中継は AI 同士のやりとりであり、人間は「次のコマンドを打つだけ」の存在になっている。個人開発ではこのオーバーヘッドが体験を著しく損ねる。
2. **コンテキスト断絶**: コマンド間で `/clear` を手動実行しているため、前のコマンドの文脈が失われる。本来不要な情報の再読み込みが発生している。
3. **P1 指摘の非収束**: レビューの P1（Nit）が毎ラウンド再生産され、実質的に収束しない。P1 の定義が広すぎるため、「具体的な改善提案」と「代替案の FYI」が混在している。手動フローでは往復コストが高いため、P1 残がある状態で通しているケースが多い。

### 放置した場合のリスク

- 個人開発における vdev フローの形骸化（手間を避けてレビューをスキップする傾向の加速）
- レビュー品質の低下（P1 対応が不十分なまま Approve される常態化）

## 3. 目的とスコープ (Goals & Non-Goals)

### 目的 (Goals)

- AI 同士のレビュー往復を自動化し、人間の手動操作を「元ネタ入力 → RFC PR マージ → 実装 PR マージ」の3回に削減する
- Severity 定義を P0/P1/P2 の3段階に再設計し、既存コマンドを含む全コマンドに統一適用することで、P1 の収束性を構造的に確保する
- シンセサイザー Task の導入により、レビュー結果の重複排除・矛盾解決・優先順位付けを自動化する
- 全 Phase の Task 化により、コンテキスト圧迫と人格混線を解消する
- `/arfc` は `/rfc` を、`/aimp` は `/imp` を内部で呼び出す構造とし、定義の重複を回避する

### やらないこと (Non-Goals)

- エンタープライズ向けプロファイル制の導入（将来課題として別 RFC で扱う）
- `/arfc` → `/aimp` の完全一気通貫自動化（RFC PR マージという人間のチェックポイントは維持する）

## 4. 前提条件・依存関係 (Prerequisites & Dependencies)

- Claude Code の Task ツール（サブエージェント）が利用可能であること
- 既存の vdev コマンド体系（`adapters/claude/commands/`）が動作していること
- `rfc-init`, `rfc-publish` スクリプトが利用可能であること

## 5. 詳細設計 (Detailed Design)

### 5.1 全体アーキテクチャ

#### 設計原則：薄いオーケストレータ

メインエージェントはループ制御と判定分岐のみを担い、ファイル読み込み・分析・執筆・レビューはすべて Task サブエージェントで実行する。

```
メインエージェント（オーケストレータ）:
  保持する情報: slug, ファイルパス, ラウンド番号, 判定結果
  行わない処理: ファイル読み込み, RFC/コード分析, 執筆, レビュー

各 Task サブエージェント:
  独立したコンテキストで起動・完了
  必要なファイルは自身で読み込む
```

この設計により以下が達成される。

- **コンテキスト圧迫の解消**: 各 Task は独立コンテキストで動作し、メインエージェントには結果のみが返る。手動フローでの `/clear` と同等以上の分離効果。
- **人格混線の解消**: RFC Author と各 Reviewer が完全に別コンテキストで動作する。Author のコンテキストに Reviewer の指摘文が蓄積しない。

#### `/arfc` のフロー

```
Phase 1: RFC作成（既存 /rfc を呼び出し）
  → メインエージェントが /rfc コマンドの処理を実行
  ← slug, RFCパス を取得

Phase 2: レビューループ（最大3イテレーション）
  Loop-A: Task x3 (Reviewer): 並列レビュー → review-*.md
  Loop-B: Task (Synthesizer): レビュー統合 → action-plan-r{N}.md
  Loop-C: 判定（メイン: action-plan の判定行を確認）
           Approve → Phase 3 へ
           Request Changes かつ iteration < 3 → Loop-D へ
           Request Changes かつ iteration >= 3 → ユーザに報告して終了
  Loop-D: Task(RFC Author): action-plan に基づきRFC修正
  → Loop-A に戻る

Phase 3: 承認完了処理（メイン直接実行）
  - RFCステータスを「Accepted」に更新
  - コミット & プッシュ
  - gh pr ready
```

#### `/aimp` のフロー

```
Phase 1: 実装（既存 /imp を呼び出し）
  → メインエージェントが /imp コマンドの処理を実行（タスク計画承認はスキップ）

Phase 2: レビューループ（最大3イテレーション）
  Loop-A: Task x3 (Reviewer): 並列レビュー → review-imp-*.md
  Loop-B: Task (Synthesizer): レビュー統合 → action-plan-imp-r{N}.md
  Loop-C: 判定（メイン: action-plan の判定行を確認）
           Approve → Phase 3 へ
           Request Changes かつ iteration < 3 → Loop-D へ
           Request Changes かつ iteration >= 3 → ユーザに報告して終了
  Loop-D: Task(Implementer): action-plan に基づきコード修正 + テスト実行
  → Loop-A に戻る

Phase 3: 承認完了処理（メイン直接実行）
  - gh pr ready
```

`/aimp` の Phase 1 では、タスク計画承認の人間チェックポイントを設けない。RFC 承認時点で設計合意は完了しており、個人開発においてタスク計画を否認する実績がないためである。実装タスクの策定から実装・テスト・PR 作成までを一気通貫で Task が実行する。

### 5.2 Severity 3段階定義

現行の P0/P1 を P0/P1/P2 の3段階に再設計し、全コマンド（既存の `/rrfc`, `/rimp` を含む）に統一適用する。

| Severity | 名称 | 定義 | Author の対応 |
| :--- | :--- | :--- | :--- |
| **P0 (Blocker)** | 修正必須 | 論理的欠陥、仕様漏れ、重大なリスク、回答必須の質問 | 必ず対応 |
| **P1 (Improvement)** | 具体的改善 | 修正内容と期待効果が明確な具体的改善提案 | 原則対応 |
| **P2 (Note)** | 記録のみ | 代替案の提示、将来的な懸念、参考情報 | 対応不要 |

#### P1 判定基準

レビュアーは以下をすべて満たす場合のみ P1 とする。

- 修正内容を具体的に示せること（「〜を検討」ではなく「〜に変更」）
- 修正による品質向上が明確であること
- 現在のスコープ内で対応可能であること

上記を満たさない指摘は P2 とする。

#### 出力上限

| Severity | 上限/レビュアー | 3レビュアー合計 | シンセサイザー統合後 |
| :--- | :--- | :--- | :--- |
| P0 | 5件 | 15件 | 重複排除後の全件 |
| P1 | 3件 | 9件 | 上位5件 |
| P2 | 2件 | 6件 | 全件（記録のみ） |

### 5.3 シンセサイザー Task

3人のレビュアーの出力を統合し、Author 向けの単一アクションプランを生成する第4の Task。

#### 入力

- `review-approach.md`（または `review-imp-approach.md`）
- `review-security-risk.md`（または `review-imp-security-risk.md`）
- `review-quality.md`（または `review-imp-quality.md`）

#### 処理

1. 全レビューから P0 / P1 / P2 を抽出する
2. 重複する指摘を統合する（同一箇所・同一趣旨 → 1件に集約）
3. 矛盾する指摘を処理する（下記の矛盾解決ルールに従う）
4. P0 を重要度順に並べる
5. P1 を対応効果が高い順に並べ、上位5件のみアクション対象とする
6. P2 を記録セクションに列挙する（対応不要と明記）
7. 解決できない矛盾がある場合、「要判断」セクションに併記する

#### 矛盾解決の処理

レビュアー間で矛盾する指摘が発生した場合、シンセサイザーは以下の手順で処理する。

**Step 1: 併存可能性の判断**

両方の指摘を同時に反映できる場合、両方をアクション対象とする（矛盾解決不要）。

- 例: 「エラーハンドリングを追加」と「ログ出力を追加」は両立可能
- 例: 「命名を改善」と「テストを追加」は両立可能

多くの「矛盾」は実際には併存可能であり、両方対応すれば解決する。

**Step 2: 排他的矛盾の自動解決（以下の条件を満たす場合のみ）**

- **Severity 差**: P0 vs P1/P2 → P0 を採用
- **根幹否定**: Approach Reviewer が「そもそもやるべきでない」「前提が誤っている」と判断 → Approach を採用

自動解決した場合、アクションプランの該当指摘に以下を付記する。

```markdown
- **矛盾解決**: {棄却したレビュアー名} の指摘「{要旨}」と矛盾。{採用理由} により本指摘を採用。
```

**Step 3: 上記以外の排他的矛盾 → 人間判断**

Step 1, 2 で解決できない排他的矛盾は、アクションプランに「要判断」セクションとして併記し、人間に委ねる。

```markdown
## 要判断（矛盾する指摘）

**[矛盾-1] {トピック}**
- **指摘A** ({レビュアー名}): {内容}
- **指摘B** ({レビュアー名}): {内容}
- **シンセサイザー所見**: {どちらが妥当と思われるかの意見}
```

自動ループは継続するが、Author は該当箇所の修正を保留する。人間が次ラウンドまでに判断し、`/urfc` で方針を指示する。

この設計により、明確なケースは自動解決し、曖昧なケースは人間に委ねる。

#### 出力フォーマット（`action-plan-r{N}.md`）

```markdown
# レビュー統合アクションプラン（ラウンド {N}）

## 判定
- **Status**: [Approve / Request Changes]
- **P0 件数**: {N} 件
- **P1 件数**: {N} 件（アクション対象: {M} 件）
- **P2 件数**: {N} 件（記録のみ）

## 必須対応 (P0)
**[P0-1] {統合後の指摘タイトル}**
- **出典**: {Approach / Security / Quality}
- **内容**: {具体的な問題点}
- **修正方針**: {具体的な修正内容}

## 推奨対応 (P1) — 上位5件
**[P1-1] {統合後の指摘タイトル}**
- **出典**: {レビュアー名}
- **内容**: {提案内容}
- **修正方針**: {具体的な修正内容}

## 記録のみ (P2)
- {内容}（出典: {レビュアー名}）

## 要判断（矛盾する指摘）
**[矛盾-1] {トピック}**
- **指摘A** ({レビュアー名}): {内容}
- **指摘B** ({レビュアー名}): {内容}
- **シンセサイザー所見**: {どちらが妥当と思われるかの意見}
```

「要判断」セクションは、矛盾が発生した場合のみ出力する。矛盾がなければ省略する。

### 5.4 ラウンド別レビュー戦略

| ラウンド | レビュー範囲 | 出力 Severity | 修正範囲 |
| :--- | :--- | :--- | :--- |
| 1 | 全文フルレビュー | P0 + P1 + P2 | P0 全件 + P1 全件（統合後最大5件） |
| 2+ | **変更差分のみ** | **P0 のみ** | P0 全件 |

#### 2ラウンド目以降のレビュー Task プロンプト追加指示

```markdown
## 追加コンテキスト（2ラウンド目以降）
- これはレビュー第{N}ラウンドである。
- 前回のアクションプラン: {action-plan-r{N-1}.md の絶対パス}
- 前回レビュー以降の変更差分のみをレビュー対象とせよ。
- P0 のみ報告せよ。P1 / P2 は報告不要。

## 変更差分の取得方法
以下の git diff コマンドを Bash ツールで実行し、差分を取得せよ:
git diff HEAD~1 -- {対象ファイルパス}

RFC レビューの場合は `docs/rfcs/<slug>/rfc.md` の差分を取得する。
実装レビューの場合はレビュー対象ファイル群の差分を取得する。
```

#### 差分レビューの実現方法

2ラウンド目以降のレビュー Task は、以下の手順で差分レビューを実行する。

1. **差分取得**: `git diff HEAD~1 -- <対象ファイル>` で前回コミットからの変更差分を取得する
2. **アクションプラン参照**: 前回の `action-plan-r{N-1}.md` を読み込み、どの指摘に対する修正かを把握する
3. **差分レビュー**: 差分箇所が指摘に対して適切に対応しているか、および新たな P0 問題が混入していないかを確認する

この方法により、Task サブエージェントは独立したコンテキストでも差分情報にアクセスできる。

2ラウンド目以降のシンセサイザーも P0 のみを処理対象とする。P1/P2 セクションは「該当なし（2ラウンド目以降は P0 限定）」と記載する。

### 5.5 ファイル管理とバージョニング

#### レビュー結果ファイル（上書き）

```
docs/rfcs/<slug>/
  review-approach.md           ← 毎ラウンド上書き
  review-security-risk.md      ← 毎ラウンド上書き
  review-quality.md            ← 毎ラウンド上書き
```

3人格のレビュー結果はシンセサイザーへの入力に過ぎないため、最新ラウンドの結果のみをファイルとして保持する。過去ラウンドの原文は git history で追跡可能。

#### アクションプラン（バージョン蓄積）

```
docs/rfcs/<slug>/
  action-plan-r1.md            ← ラウンド1の統合結果（保持）
  action-plan-r2.md            ← ラウンド2の統合結果（保持）
  action-plan-r3.md            ← ラウンド3の統合結果（保持）
```

アクションプランは自動化プロセスの監査証跡として機能する。ラウンド間の変化（P0 件数の推移、指摘内容の変遷）を人間が後から追跡できる。

実装レビューでは `action-plan-imp-r{N}.md` とする。

#### コミット戦略

ラウンドごとにまとめてコミットし、コミットメッセージにラウンド番号を含める。

```
# ラウンド1 レビュー結果
docs: add review results (round 1) for <slug>

# ラウンド1 RFC修正
docs: revise RFC for <slug> (round 1 fixes)

# ラウンド2 レビュー結果
docs: add review results (round 2) for <slug>
```

### 5.6 新規ファイル一覧

| ファイル | 配置先 | 説明 |
| :--- | :--- | :--- |
| `arfc.md` | `adapters/claude/commands/` | `/arfc` コマンド定義 |
| `aimp.md` | `adapters/claude/commands/` | `/aimp` コマンド定義 |
| `synthesizer.md` | `prompts/roles/` | シンセサイザー人格定義 |
| `review-default.md` | `templates/review/` | 既存テンプレートを P0/P1/P2 に更新 |
| `action-plan-default.md` | `templates/review/` | アクションプランテンプレート |

### 5.7 既存ファイル変更一覧

| ファイル | 変更内容 |
| :--- | :--- |
| `prompts/criterias/rfc-review.md` | P1 判定基準の追記、P2 定義の追加 |
| `prompts/criterias/impl-review.md` | 同上 |
| `adapters/claude/commands/rrfc.md` | Severity 定義を P0/P1/P2 に更新、レビューテンプレート参照先の変更 |
| `adapters/claude/commands/rimp.md` | 同上 |
| `adapters/claude/commands/urfc.md` | P2 対応不要の方針を明記 |
| `adapters/claude/commands/uimp.md` | 同上 |
| `templates/review/review-default.md` | P2 セクションの追加 |

Severity 3段階定義は全コマンドに統一適用する。既存コマンドと新コマンドで異なる Severity 体系が併存する状態を避け、保守性を確保する。

## 6. 代替案の検討 (Alternatives Considered)

### 案A: 既存コマンドにフラグ追加（`/rrfc --auto`）

- **概要**: 既存の `/rrfc`, `/rimp` に `--auto` フラグを追加し、Request Changes 時に自動で修正→再レビューを実行する。
- **長所**: 新規コマンド不要。既存コマンドの拡張で済む。
- **短所**: 既存コマンドの複雑化。フラグの有無で挙動が大きく変わり、保守性が低下する。既存コマンドの安定性にリスクが及ぶ。

### 案B: シェルスクリプトによるオーケストレーション

- **概要**: `bin/auto-rfc` のようなシェルスクリプトで `/rfc` → `/rrfc` → `/urfc` を順次呼び出す。
- **長所**: コマンド定義に手を入れずに実現可能。
- **短所**: Claude Code のスラッシュコマンドはシェルから呼び出せない（AI プロンプトとして実行される仕組み）。技術的に実現不可能。

### 案C: 新規複合コマンド + シンセサイザー + Severity 統一再設計（採用案）

- **概要**: `/arfc`, `/aimp` を新設。薄いオーケストレータ + 全 Phase Task 化 + シンセサイザー + P0/P1/P2 の3段階 Severity を全コマンドに統一適用。`/arfc` は `/rfc` を、`/aimp` は `/imp` を内部で呼び出す構造とし、定義の重複を回避。
- **長所**: Severity 定義が一元化され保守性向上。コンテキスト分離が構造的に保証される。P1 収束問題を Severity 再設計とシンセサイザーで根本解決。既存ロジックを再利用することで新コマンドの定義が簡潔になる。
- **短所**: 既存コマンドの変更が必要（リグレッションリスク）。シンセサイザーという新しい概念の導入。

### 選定理由

案C を採用する。案A は既存コマンドの複雑化リスクがあり、案B は技術的に不可能である。案C は Severity 定義の二重管理を避け、既存コマンドと新コマンドで一貫した体験を提供できる。既存コマンドの変更によるリグレッションリスクはあるが、変更範囲が Severity 定義の更新に限定されるため、影響は軽微である。`/arfc` が `/rfc` を呼び出す構造により、RFC 作成ロジックの一元管理も実現する。

## 7. 横断的関心事 (Cross-Cutting Concerns)

### 7.1 セキュリティとプライバシー

本変更はローカル開発ワークフローの自動化であり、セキュリティ上の新たなリスクはない。

### 7.2 スケーラビリティとパフォーマンス

- **Token 消費**: 全 Phase Task 化により、メインエージェントの Token 消費は大幅に削減される。一方、Task 起動数が増えるため、全体の Token 消費はやや増加する可能性がある（シンセサイザー Task の追加分）。
- **実行時間**: 並列レビュー（3 Task 同時）は維持。シンセサイザー Task は直列追加（+1 Task）。全体の実行時間はシンセサイザー分だけ増加するが、手動でのコマンド入力待ち時間の削減により、エンドツーエンドの所要時間は短縮される。

### 7.3 可観測性 (Observability)

- アクションプランのバージョンファイル（`action-plan-r{N}.md`）がプロセスの監査証跡として機能する
- コミットメッセージにラウンド番号を含めることで、git history からも追跡可能

### 7.4 マイグレーションと後方互換性

- 既存コマンド（`/rrfc`, `/rimp`, `/urfc`, `/uimp`）の Severity 定義を P0/P1/P2 に変更する
- 既存コマンドの利用者への影響:
  - レビュー出力に P2 カテゴリが追加される（新規追加、情報量増加）
  - P1 の定義が厳格化される（「具体的改善提案」に限定）
  - 従来 P1 だった一部の指摘が P2 に分類される（対応負荷軽減）
- 既存コマンドを使い続けることも可能（`/arfc` と `/rfc` + `/rrfc` + `/urfc` は共存する）
- 破壊的変更はなく、出力フォーマットの拡張のみ

## 8. テスト戦略 (Test Strategy)

vdev はプロンプト定義とシェルスクリプトで構成されるため、自動テストの対象は限定的である。以下の手動検証を行う。

- `/arfc` を実プロジェクトで実行し、レビューループが正常に動作することを確認する
  - Phase 1（RFC作成）が Task として正常に完了すること
  - Phase 2（レビューループ）で3並列レビュー + シンセサイザーが動作すること
  - Request Changes 時にループが継続し、Approve 時に終了すること
  - 最大3イテレーションでガードされること
  - アクションプランが `action-plan-r{N}.md` として蓄積されること
- `/aimp` を実プロジェクトで実行し、同等の検証を行う
  - Phase 1 で実装タスク策定から PR 作成まで一気通貫で完了すること
  - テスト実行が修正ループ内で正常に動作すること
- Severity 3段階（P0/P1/P2）が正しく分類されることを確認する
- シンセサイザーの重複排除・矛盾解決が妥当であることを確認する

## 9. 実装・リリース計画 (Implementation Plan)

### フェーズ1: 基盤整備と既存コマンド更新

1. Severity 3段階定義の追加（`prompts/criterias/rfc-review.md`, `impl-review.md`）
2. レビューテンプレートの更新（`templates/review/review-default.md` に P2 追加）
3. 既存レビューコマンドの更新（`rrfc.md`, `rimp.md` の Severity 定義を P0/P1/P2 に変更）
4. 既存修正コマンドの更新（`urfc.md`, `uimp.md` に P2 対応不要の方針を明記）
5. シンセサイザー人格定義の作成（`prompts/roles/synthesizer.md`）
6. アクションプランテンプレートの作成（`templates/review/action-plan-default.md`）

### フェーズ2: /arfc コマンド実装

1. `adapters/claude/commands/arfc.md` の作成（`/rfc` を内部で呼び出す構造）
2. 実プロジェクトでの動作検証

### フェーズ3: /aimp コマンド実装

1. `adapters/claude/commands/aimp.md` の作成（`/imp` を内部で呼び出す構造）
2. 実プロジェクトでの動作検証

### システム概要ドキュメントへの影響

vdev リポジトリには `docs/architecture.md` 等のシステム概要ドキュメントは存在しないため、影響なし。
